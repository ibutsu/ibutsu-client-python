"""
Ibutsu API

A system to store and query test results

The version of the OpenAPI document: 2.8.3
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
from uuid import uuid4

import pytest

from ibutsu_client.models.result import Result


class TestResult:
    """Result model tests"""

    def test_result_creation_empty(self):
        """Test Result creation with no parameters"""
        result = Result()
        assert result.id is None
        assert result.test_id is None
        assert result.result is None

    def test_result_creation_with_required(self):
        """Test Result creation with required params only (none are strictly required in init)"""
        result = Result(test_id="test_case_1")
        assert result.test_id == "test_case_1"

    def test_result_creation_full(self):
        """Test Result creation with all parameters"""
        run_id = uuid4()
        project_id = uuid4()
        result_id = uuid4()

        result = Result(
            id=result_id,
            test_id="test_full_create",
            start_time="2023-01-01T12:00:00Z",
            duration=10.5,
            result="passed",
            component="backend",
            env="ci",
            run_id=run_id,
            project_id=project_id,
            metadata={"key": "value"},
            params={"param1": "value1"},
            source="jenkins",
        )

        assert result.id == result_id
        assert result.test_id == "test_full_create"
        assert result.duration == 10.5
        assert result.result == "passed"
        assert result.metadata == {"key": "value"}

    def test_result_validate_enum_valid(self):
        """Test valid enum values for result field"""
        valid_results = [
            "passed",
            "failed",
            "error",
            "skipped",
            "xpassed",
            "xfailed",
            "manual",
            "blocked",
        ]
        for res in valid_results:
            r = Result(result=res)
            assert r.result == res

    def test_result_validate_enum_invalid(self):
        """Test invalid enum values for result field raises ValueError"""
        with pytest.raises(ValueError, match="must be one of enum values"):
            Result(result="invalid_status")

    def test_result_to_dict(self):
        """Test Result to_dict conversion"""
        result = Result(test_id="test_dict", result="passed")
        result_dict = result.to_dict()

        assert isinstance(result_dict, dict)
        assert result_dict["test_id"] == "test_dict"
        assert result_dict["result"] == "passed"

    def test_result_to_json(self):
        """Test Result to_json conversion"""
        result = Result(test_id="test_json", result="failed")
        result_json = result.to_json()

        assert isinstance(result_json, str)
        parsed = json.loads(result_json)
        assert parsed["test_id"] == "test_json"
        assert parsed["result"] == "failed"

    def test_result_from_dict(self):
        """Test Result from_dict creation"""
        result_dict = {"test_id": "test_from_dict", "result": "error"}
        result = Result.from_dict(result_dict)

        assert isinstance(result, Result)
        assert result.test_id == "test_from_dict"
        assert result.result == "error"

    def test_result_from_json(self):
        """Test Result from_json creation"""
        result_json = '{"test_id": "test_from_json", "result": "skipped"}'
        result = Result.from_json(result_json)

        assert isinstance(result, Result)
        assert result.test_id == "test_from_json"
        assert result.result == "skipped"

    def test_result_to_str(self):
        """Test Result to_str representation"""
        result = Result(test_id="test_str")
        result_str = result.to_str()

        assert isinstance(result_str, str)
        assert "test_str" in result_str

    def test_result_none_values_excluded(self):
        """Test that None values are excluded from dict"""
        result = Result(test_id="test_none")
        result_dict = result.to_dict()

        assert "test_id" in result_dict
        assert "duration" not in result_dict

    def test_result_from_dict_none(self):
        """Test Result.from_dict with None returns None"""
        result = Result.from_dict(None)
        assert result is None

    def test_result_none_result(self):
        """Test result field can be explicitly None"""
        result = Result(result=None)
        assert result.result is None

    def test_result_explicit_nones(self):
        """Test explicit None values are preserved in to_dict if set"""
        # By default unset optional fields are not in model_fields_set and excluded by exclude_none=True
        # But if we explicitly set them to None, the custom to_dict logic should include them
        result = Result(component=None, env=None, run_id=None, project_id=None)
        result_dict = result.to_dict()

        assert "component" in result_dict
        assert result_dict["component"] is None
        assert "env" in result_dict
        assert result_dict["env"] is None
        assert "run_id" in result_dict
        assert result_dict["run_id"] is None
        assert "project_id" in result_dict
        assert result_dict["project_id"] is None

    def test_result_from_dict_non_dict(self):
        """Test from_dict with a non-dict object (e.g. another model instance or compatible object)"""
        # This hits the path where obj is not a dict
        # model_validate can accept the object itself if it's compatible
        res_obj = Result(test_id="test_obj")
        new_res = Result.from_dict(res_obj)
        assert new_res.test_id == "test_obj"

    def test_result_roundtrip_json(self):
        """Test Result can be serialized and deserialized"""
        original = Result(test_id="test_roundtrip", result="passed")
        json_str = original.to_json()
        restored = Result.from_json(json_str)

        assert restored.test_id == original.test_id
        assert restored.result == original.result
