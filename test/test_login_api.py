"""
Ibutsu API

A system to store and query test results

The version of the OpenAPI document: 2.8.3
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import pytest

from ibutsu_client.api.login_api import LoginApi
from ibutsu_client.exceptions import NotFoundException, ServiceException
from ibutsu_client.models.login_config import LoginConfig
from ibutsu_client.models.login_support import LoginSupport
from ibutsu_client.models.login_token import LoginToken


class TestLoginApi:
    """LoginApi comprehensive tests"""

    def test_activate_success(self, mocker):
        """Test case for activate with successful activation"""
        api = LoginApi()
        from ibutsu_client.api_response import ApiResponse

        # Mock response_deserialize to return ApiResponse with None data (302 redirect)
        mock_api_response = ApiResponse(status_code=302, data=None, headers={}, raw_data=b"")
        mocker.patch.object(api.api_client, "response_deserialize", return_value=mock_api_response)
        mocker.patch.object(api.api_client, "call_api")

        # Should not raise exception for 302 redirect
        result = api.activate(activation_code="test-activation-code")
        assert result is None
        api.api_client.call_api.assert_called_once()

    @pytest.mark.parametrize(
        "create_mock_response",
        [{"data": {"error": "not found"}, "status": 404}],
        indirect=True,
    )
    def test_activate_not_found(self, mocker, create_mock_response):
        """Test case for activate with invalid activation code"""
        api = LoginApi()
        mocker.patch.object(api.api_client, "call_api", return_value=create_mock_response)

        with pytest.raises(NotFoundException):
            api.activate(activation_code="invalid-code")

    def test_activate_with_http_info(self, mocker):
        """Test case for activate_with_http_info"""
        api = LoginApi()
        from ibutsu_client.api_response import ApiResponse

        # Mock response_deserialize to return ApiResponse with None data (302 redirect)
        mock_api_response = ApiResponse(status_code=302, data=None, headers={}, raw_data=b"")
        mocker.patch.object(api.api_client, "response_deserialize", return_value=mock_api_response)
        mocker.patch.object(api.api_client, "call_api")

        result = api.activate_with_http_info(activation_code="test-code")
        assert result.status_code == 302
        assert result.data is None

    def test_auth_success(self, mocker):
        """Test case for auth - redirects to OAuth provider"""
        api = LoginApi()
        from ibutsu_client.api_response import ApiResponse

        # auth() returns None (302 redirect to OAuth provider)
        mock_api_response = ApiResponse(status_code=302, data=None, headers={}, raw_data=b"")
        mocker.patch.object(api.api_client, "response_deserialize", return_value=mock_api_response)
        mocker.patch.object(api.api_client, "call_api")

        result = api.auth(provider="oidc")
        assert result is None
        api.api_client.call_api.assert_called_once()

    @pytest.mark.parametrize(
        "create_mock_response",
        [{"data": {"error": "invalid provider"}, "status": 400}],
        indirect=True,
    )
    def test_auth_unauthorized(self, mocker, create_mock_response):
        """Test case for auth with invalid provider"""
        api = LoginApi()
        mocker.patch.object(api.api_client, "call_api", return_value=create_mock_response)

        with pytest.raises(
            (ServiceException, Exception)
        ):  # Should raise appropriate auth exception
            api.auth(provider="invalid")

    def test_auth_with_http_info(self, mocker):
        """Test case for auth_with_http_info - redirects to OAuth provider"""
        api = LoginApi()
        from ibutsu_client.api_response import ApiResponse

        # auth() returns None (302 redirect to OAuth provider)
        mock_api_response = ApiResponse(status_code=302, data=None, headers={}, raw_data=b"")
        mocker.patch.object(api.api_client, "response_deserialize", return_value=mock_api_response)
        mocker.patch.object(api.api_client, "call_api")

        result = api.auth_with_http_info(provider="oidc")
        assert result.status_code == 302
        assert result.data is None

    @pytest.mark.parametrize(
        "create_mock_response",
        [
            {
                "data": {
                    "client_id": "test-client-id",
                    "redirect_uri": "https://example.com/callback",
                    "scope": "openid profile email",
                },
                "status": 200,
            }
        ],
        indirect=True,
    )
    def test_config_success(self, mocker, create_mock_response):
        """Test case for config - get login configuration"""
        api = LoginApi()
        mocker.patch.object(api.api_client, "call_api", return_value=create_mock_response)

        result = api.config(provider="oidc")
        assert isinstance(result, LoginConfig)
        assert result.client_id == "test-client-id"
        assert result.redirect_uri == "https://example.com/callback"

    @pytest.mark.parametrize(
        "create_mock_response",
        [{"data": {"client_id": "test-client"}, "status": 200}],
        indirect=True,
    )
    def test_config_with_http_info(self, mocker, create_mock_response):
        """Test case for config_with_http_info"""
        api = LoginApi()
        mocker.patch.object(api.api_client, "call_api", return_value=create_mock_response)

        result = api.config_with_http_info(provider="oidc")
        assert result.status_code == 200
        assert isinstance(result.data, LoginConfig)

    @pytest.mark.parametrize(
        "create_mock_response",
        [
            {
                "data": {
                    "token": "jwt-token-here",
                    "refresh_token": "refresh-token-here",
                },
                "status": 200,
            }
        ],
        indirect=True,
    )
    def test_login_success(self, mocker, create_mock_response):
        """Test case for login with valid credentials"""
        api = LoginApi()
        mocker.patch.object(api.api_client, "call_api", return_value=create_mock_response)

        from ibutsu_client.models.credentials import Credentials

        credentials = Credentials(email="test@example.com", password="password123")
        result = api.login(credentials=credentials)
        assert isinstance(result, LoginToken)
        assert result.token == "jwt-token-here"

    @pytest.mark.parametrize(
        "create_mock_response",
        [{"data": {"error": "invalid credentials"}, "status": 401}],
        indirect=True,
    )
    def test_login_invalid_credentials(self, mocker, create_mock_response):
        """Test case for login with invalid credentials"""
        api = LoginApi()
        mocker.patch.object(api.api_client, "call_api", return_value=create_mock_response)

        from ibutsu_client.models.credentials import Credentials

        credentials = Credentials(email="wrong@example.com", password="wrongpass")
        with pytest.raises((ServiceException, Exception)):
            api.login(credentials=credentials)

    @pytest.mark.parametrize(
        "create_mock_response",
        [{"data": {"token": "test-token"}, "status": 200}],
        indirect=True,
    )
    def test_login_with_http_info(self, mocker, create_mock_response):
        """Test case for login_with_http_info"""
        api = LoginApi()
        mocker.patch.object(api.api_client, "call_api", return_value=create_mock_response)

        from ibutsu_client.models.credentials import Credentials

        credentials = Credentials(email="test@example.com", password="pass")
        result = api.login_with_http_info(credentials=credentials)
        assert result.status_code == 200
        assert isinstance(result.data, LoginToken)

    @pytest.mark.parametrize(
        "create_mock_response",
        [{"data": {}, "status": 200}],
        indirect=True,
    )
    def test_recover_success(self, mocker, create_mock_response):
        """Test case for recover - initiate password recovery"""
        api = LoginApi()
        mocker.patch.object(api.api_client, "call_api", return_value=create_mock_response)

        from ibutsu_client.models.account_recovery import AccountRecovery

        recovery_data = AccountRecovery(email="test@example.com")
        api.recover(account_recovery=recovery_data)
        # Method should complete without raising exception
        api.api_client.call_api.assert_called_once()

    @pytest.mark.parametrize(
        "create_mock_response",
        [{"data": {"error": "user not found"}, "status": 404}],
        indirect=True,
    )
    def test_recover_not_found(self, mocker, create_mock_response):
        """Test case for recover with non-existent email"""
        api = LoginApi()
        mocker.patch.object(api.api_client, "call_api", return_value=create_mock_response)

        from ibutsu_client.models.account_recovery import AccountRecovery

        recovery_data = AccountRecovery(email="nonexistent@example.com")
        with pytest.raises(NotFoundException):
            api.recover(account_recovery=recovery_data)

    @pytest.mark.parametrize(
        "create_mock_response",
        [{"data": {}, "status": 200}],
        indirect=True,
    )
    def test_recover_with_http_info(self, mocker, create_mock_response):
        """Test case for recover_with_http_info"""
        api = LoginApi()
        mocker.patch.object(api.api_client, "call_api", return_value=create_mock_response)

        from ibutsu_client.models.account_recovery import AccountRecovery

        recovery_data = AccountRecovery(email="test@example.com")
        result = api.recover_with_http_info(account_recovery=recovery_data)
        assert result.status_code == 200

    @pytest.mark.parametrize(
        "create_mock_response",
        [{"data": {"message": "Registration successful"}, "status": 201}],
        indirect=True,
    )
    def test_register_success(self, mocker, create_mock_response):
        """Test case for register with valid registration data"""
        api = LoginApi()
        mocker.patch.object(api.api_client, "call_api", return_value=create_mock_response)

        from ibutsu_client.models.account_registration import AccountRegistration

        registration = AccountRegistration(
            email="newuser@example.com", password="securepass123", name="New User"
        )
        api.register(account_registration=registration)
        api.api_client.call_api.assert_called_once()

    @pytest.mark.parametrize(
        "create_mock_response",
        [{"data": {"error": "email already exists"}, "status": 409}],
        indirect=True,
    )
    def test_register_conflict(self, mocker, create_mock_response):
        """Test case for register with existing email"""
        api = LoginApi()
        mocker.patch.object(api.api_client, "call_api", return_value=create_mock_response)

        from ibutsu_client.models.account_registration import AccountRegistration

        registration = AccountRegistration(
            email="existing@example.com", password="pass123", name="User"
        )
        with pytest.raises((ServiceException, Exception)):  # Should raise conflict exception
            api.register(account_registration=registration)

    @pytest.mark.parametrize(
        "create_mock_response",
        [{"data": {"message": "success"}, "status": 201}],
        indirect=True,
    )
    def test_register_with_http_info(self, mocker, create_mock_response):
        """Test case for register_with_http_info"""
        api = LoginApi()
        mocker.patch.object(api.api_client, "call_api", return_value=create_mock_response)

        from ibutsu_client.models.account_registration import AccountRegistration

        registration = AccountRegistration(email="test@example.com", password="pass", name="Test")
        result = api.register_with_http_info(account_registration=registration)
        assert result.status_code == 201

    @pytest.mark.parametrize(
        "create_mock_response",
        [{"data": {}, "status": 200}],
        indirect=True,
    )
    def test_reset_password_success(self, mocker, create_mock_response):
        """Test case for reset_password with valid reset data"""
        api = LoginApi()
        mocker.patch.object(api.api_client, "call_api", return_value=create_mock_response)

        from ibutsu_client.models.account_reset import AccountReset

        reset_data = AccountReset(activation_code="reset-code-123", password="newpass123")
        api.reset_password(account_reset=reset_data)
        api.api_client.call_api.assert_called_once()

    @pytest.mark.parametrize(
        "create_mock_response",
        [{"data": {"error": "invalid reset code"}, "status": 400}],
        indirect=True,
    )
    def test_reset_password_invalid_code(self, mocker, create_mock_response):
        """Test case for reset_password with invalid reset code"""
        api = LoginApi()
        mocker.patch.object(api.api_client, "call_api", return_value=create_mock_response)

        from ibutsu_client.models.account_reset import AccountReset

        reset_data = AccountReset(activation_code="invalid-code", password="newpass")
        with pytest.raises((ServiceException, Exception)):
            api.reset_password(account_reset=reset_data)

    @pytest.mark.parametrize(
        "create_mock_response",
        [{"data": {}, "status": 200}],
        indirect=True,
    )
    def test_reset_password_with_http_info(self, mocker, create_mock_response):
        """Test case for reset_password_with_http_info"""
        api = LoginApi()
        mocker.patch.object(api.api_client, "call_api", return_value=create_mock_response)

        from ibutsu_client.models.account_reset import AccountReset

        reset_data = AccountReset(activation_code="code", password="newpass")
        result = api.reset_password_with_http_info(account_reset=reset_data)
        assert result.status_code == 200

    @pytest.mark.parametrize(
        "create_mock_response",
        [
            {
                "data": {
                    "user": True,
                    "keycloak": True,
                    "google": False,
                    "github": False,
                    "facebook": False,
                    "gitlab": False,
                },
                "status": 200,
            }
        ],
        indirect=True,
    )
    def test_support_success(self, mocker, create_mock_response):
        """Test case for support - get support configuration"""
        api = LoginApi()
        mocker.patch.object(api.api_client, "call_api", return_value=create_mock_response)

        result = api.support()
        assert isinstance(result, LoginSupport)
        assert result.user is True
        assert result.keycloak is True

    @pytest.mark.parametrize(
        "create_mock_response",
        [{"data": {"user": True, "google": True}, "status": 200}],
        indirect=True,
    )
    def test_support_with_http_info(self, mocker, create_mock_response):
        """Test case for support_with_http_info"""
        api = LoginApi()
        mocker.patch.object(api.api_client, "call_api", return_value=create_mock_response)

        result = api.support_with_http_info()
        assert result.status_code == 200
        assert isinstance(result.data, LoginSupport)

    @pytest.mark.parametrize(
        "create_mock_response",
        [{"data": {"error": "internal error"}, "status": 500}],
        indirect=True,
    )
    def test_support_server_error(self, mocker, create_mock_response):
        """Test case for support with server error"""
        api = LoginApi()
        mocker.patch.object(api.api_client, "call_api", return_value=create_mock_response)

        with pytest.raises(ServiceException):
            api.support()
